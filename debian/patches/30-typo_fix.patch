diff --git a/ChangeLog b/ChangeLog
index d529664..b611b3d 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1317,7 +1317,7 @@
 2008-09-30  Dan Williams  <dcbw@redhat.com>
 
 	* src/NetworkManagerPolicy.c
-		- (lookup_thread_worker): don't store the idle handler ID becuase the
+		- (lookup_thread_worker): don't store the idle handler ID because the
 			idle handler could have already run and freed the LookupThread
 			structure
 
@@ -8391,7 +8391,7 @@
 			internally; clients should provide a setting that applies to
 			the device with 'autoconnect: True'.  Problem was that these
 			internally auto-created connections don't have a proxy or service
-			name becuase they weren't created by a settings daemon, and therefore
+			name because they weren't created by a settings daemon, and therefore
 			clients have no idea what to do with them.
 
 2007-10-03  Dan Williams  <dcbw@redhat.com>
@@ -9794,7 +9794,7 @@
 	* libnm-glib/nm-settings.c
 	  libnm-glib/nm-settings.h
 		- make the dbus path a property of the object, and autogenerate it.
-		It can't be composed of the 'id' field becuase that's not available
+		It can't be composed of the 'id' field because that's not available
 		yet during the GObject creation in nm_connection_settings_init()
 
 2007-08-29  Dan Williams  <dcbw@redhat.com>
diff --git a/README b/README
index acb807b..286cabc 100644
--- a/README
+++ b/README
@@ -66,11 +66,11 @@ those drivers that are shipped with the upstream Linux kernel, because only
 those drivers can be easily fixed and debugged.  ndiswrapper, vendor binary
 drivers, or other out-of-tree drivers may or may not work well with
 NetworkManager, precisely because they have not been vetted and improved by the
-open-source community, and becuase problems in these drivers usually cannot
+open-source community, and because problems in these drivers usually cannot
 be fixed.
 
 Sometimes, command-line tools like 'iwconfig' will work, but NetworkManager will
-fail.  This is again often due to buggy drivers, becuase these drivers simply
+fail.  This is again often due to buggy drivers, because these drivers simply
 aren't expecting the dynamic requests that NetworkManager and wpa_supplicant
 make.  Driver bugs should be filed in the bug tracker of the distribution being
 run, since often distributions customize their kernel and drivers.
diff --git a/libnm-glib/nm-device.c b/libnm-glib/nm-device.c
index 5e9eb50..120be3f 100644
--- a/libnm-glib/nm-device.c
+++ b/libnm-glib/nm-device.c
@@ -1084,7 +1084,7 @@ nm_device_update_description (NMDevice *device)
 	 * vendor and device ID information off it.
 	 */
 
-	/* Ref the device again becuase we have to unref it each iteration,
+	/* Ref the device again because we have to unref it each iteration,
 	 * as g_udev_device_get_parent() returns a ref-ed object.
 	 */
 	tmpdev = g_object_ref (udev_device);
diff --git a/src/dhcp-manager/nm-dhcp-dhclient.c b/src/dhcp-manager/nm-dhcp-dhclient.c
index bb5cd2e..26a2b7b 100644
--- a/src/dhcp-manager/nm-dhcp-dhclient.c
+++ b/src/dhcp-manager/nm-dhcp-dhclient.c
@@ -385,7 +385,7 @@ merge_dhclient_config (const char *iface,
 			}
 
 			/* If the client ID is just hex digits and : then don't use quotes,
-			 * becuase dhclient expects either a quoted ASCII string, or a byte
+			 * because dhclient expects either a quoted ASCII string, or a byte
 			 * array formated as hex octets separated by :
 			 */
 			if (is_octets)
diff --git a/src/nm-device.c b/src/nm-device.c
index 176d90f..906abd4 100644
--- a/src/nm-device.c
+++ b/src/nm-device.c
@@ -3683,7 +3683,7 @@ nm_device_state_changed (NMDevice *device,
 	case NM_DEVICE_STATE_UNAVAILABLE:
 		/* If the device can activate now (ie, it's got a carrier, the supplicant
 		 * is active, or whatever) schedule a delayed transition to DISCONNECTED
-		 * to get things rolling.  The device can't transition immediately becuase
+		 * to get things rolling.  The device can't transition immediately because
 		 * we can't change states again from the state handler for a variety of
 		 * reasons.
 		 */
@@ -3704,7 +3704,7 @@ nm_device_state_changed (NMDevice *device,
 	case NM_DEVICE_STATE_FAILED:
 		nm_log_warn (LOGD_DEVICE, "Activation (%s) failed.", nm_device_get_iface (device));
 		/* Schedule the transition to DISCONNECTED.  The device can't transition
-		 * immediately becuase we can't change states again from the state
+		 * immediately because we can't change states again from the state
 		 * handler for a variety of reasons.
 		 */
 		priv->failed_to_disconnected_id = g_idle_add (failed_to_disconnected, device);
diff --git a/system-settings/plugins/ifcfg-rh/reader.c b/system-settings/plugins/ifcfg-rh/reader.c
index 1c7e8eb..3697737 100644
--- a/system-settings/plugins/ifcfg-rh/reader.c
+++ b/system-settings/plugins/ifcfg-rh/reader.c
@@ -1874,7 +1874,7 @@ parse_wpa_psk (shvarFile *ifcfg,
 	char *psk = NULL, *p, *hashed = NULL;
 	gboolean quoted = FALSE;
 
-	/* Passphrase must be between 10 and 66 characters in length becuase WPA
+	/* Passphrase must be between 10 and 66 characters in length because WPA
 	 * hex keys are exactly 64 characters (no quoting), and WPA passphrases
 	 * are between 8 and 63 characters (inclusive), plus optional quoting if
 	 * the passphrase contains spaces.
diff --git a/system-settings/plugins/keyfile/io/reader.c b/system-settings/plugins/keyfile/io/reader.c
index 5582733..cbcb42c 100644
--- a/system-settings/plugins/keyfile/io/reader.c
+++ b/system-settings/plugins/keyfile/io/reader.c
@@ -738,7 +738,7 @@ typedef struct {
 	void (*parser) (NMSetting *setting, const char *key, GKeyFile *keyfile);
 } KeyParser;
 
-/* A table of keys that require further parsing/conversion becuase they are
+/* A table of keys that require further parsing/conversion because they are
  * stored in a format that can't be automatically read using the key's type.
  * i.e. IPv4 addresses, which are stored in NetworkManager as guint32, but are
  * stored in keyfiles as strings, eg "10.1.1.2" or IPv6 addresses stored 
diff --git a/system-settings/plugins/keyfile/io/writer.c b/system-settings/plugins/keyfile/io/writer.c
index 348fa51..06b5b85 100644
--- a/system-settings/plugins/keyfile/io/writer.c
+++ b/system-settings/plugins/keyfile/io/writer.c
@@ -460,7 +460,7 @@ typedef struct {
 	void (*writer) (GKeyFile *keyfile, NMSetting *setting, const char *key, const GValue *value);
 } KeyWriter;
 
-/* A table of keys that require further parsing/conversion becuase they are
+/* A table of keys that require further parsing/conversion because they are
  * stored in a format that can't be automatically read using the key's type.
  * i.e. IPv4 addresses, which are stored in NetworkManager as guint32, but are
  * stored in keyfiles as strings, eg "10.1.1.2" or IPv6 addresses stored 
