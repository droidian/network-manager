Squash the following commits into one patch

d0cdbf3525b105de6dc0ca4ce02801bfe8fe2222
4c36f7c0b607813753072acf1bec14414494948c
d185695d80b248354dd7a95fd896daa5c45085e5

modem: handle newer HAL versions where info.bus is no longer present

hal: find driver for ibmebus-type 'ehea' devices

core: handle new 'ssb' bus from HAL 0.5.13 (deb #540613)

HAL added 'ssb' (Silicon Sonics Backplane, used internally on most
Broadcom ethernet and wifi chipsets) in 0.5.13, which changed the
device list layout and made NM unable to get the driver for the
wifi device.  Fix that.
---
 src/nm-hal-manager.c |  133 +++++++++++++++++++++++++++++--------------------
 1 files changed, 79 insertions(+), 54 deletions(-)

diff --git a/src/nm-hal-manager.c b/src/nm-hal-manager.c
index 647fe21..a01b4e2 100644
--- a/src/nm-hal-manager.c
+++ b/src/nm-hal-manager.c
@@ -124,19 +124,45 @@ get_creator (NMHalManager *self, const char *udi)
 /* Common helpers for built-in device creators */
 
 static char *
+hal_get_subsystem (LibHalContext *ctx, const char *udi)
+{
+	char *subsys;
+
+	subsys = libhal_device_get_property_string (ctx, udi, "info.subsystem", NULL);
+	if (!subsys) {
+		/* info.bus is deprecated */
+		subsys = libhal_device_get_property_string (ctx, udi, "info.bus", NULL);
+	}
+	return subsys;
+}
+
+static char *
 nm_get_device_driver_name (LibHalContext *ctx, const char *origdev_udi)
 {
-	char *driver_name = NULL;
+	char *driver_name = NULL, *subsystem, *drv, *od_parent = NULL;
 
-	if (origdev_udi && libhal_device_property_exists (ctx, origdev_udi, "info.linux.driver", NULL)) {
-		char *drv;
+	if (!origdev_udi)
+		return NULL;
 
-		drv = libhal_device_get_property_string (ctx, origdev_udi, "info.linux.driver", NULL);
-		if (drv) {
-			driver_name = g_strdup (drv);
-			libhal_free_string (drv);
+	/* s390 driver name is on the grandparent of the net device */
+	subsystem = hal_get_subsystem (ctx, origdev_udi);
+	if (subsystem) {
+		if (!strcmp (subsystem, "ibmebus")) {
+			od_parent = libhal_device_get_property_string (ctx, origdev_udi, "info.parent", NULL);
+			origdev_udi = (const char *) od_parent;
+		} else if (!strcmp (subsystem, "ssb")) {
+			od_parent = libhal_device_get_property_string (ctx, origdev_udi, "info.parent", NULL);
+			origdev_udi = (const char *) od_parent;
 		}
 	}
+
+	drv = libhal_device_get_property_string (ctx, origdev_udi, "info.linux.driver", NULL);
+	if (drv)
+		driver_name = g_strdup (drv);
+
+	libhal_free_string (drv);
+	libhal_free_string (od_parent);
+	libhal_free_string (subsystem);
 	return driver_name;
 }
 
@@ -292,18 +318,34 @@ is_modem_device (NMHalManager *self, const char *udi)
 }
 
 static char *
+hal_get_originating_device (LibHalContext *ctx, const char *udi, const char *prefix)
+{
+	char *od_key = g_strdup_printf ("%s.originating_device", prefix);
+	char *pd_key = g_strdup_printf ("%s.physical_device", prefix);
+	char *od;
+
+	od = libhal_device_get_property_string (ctx, udi, od_key, NULL);
+	if (!od) {
+		/* physical_device is deprecated */
+		od = libhal_device_get_property_string (ctx, udi, pd_key, NULL);
+	}
+
+	g_free (od_key);
+	g_free (pd_key);
+	return od;
+}
+
+static char *
 get_hso_netdev (LibHalContext *ctx, const char *udi)
 {
-	char *serial_od = NULL, *serial_od_parent = NULL, *netdev = NULL, *bus;
+	char *serial_od = NULL, *serial_od_parent = NULL, *netdev = NULL, *subsys;
 	char **netdevs = NULL;
 	int num, i;
 
 	/* Get the serial interface's originating device UDI, used to find the
 	 * originating device's netdev.
 	 */
-	serial_od = libhal_device_get_property_string (ctx, udi, "serial.originating_device", NULL);
-	if (!serial_od)
-		serial_od = libhal_device_get_property_string (ctx, udi, "serial.physical_device", NULL);
+	serial_od = hal_get_originating_device (ctx, udi, "serial");
 	if (!serial_od)
 		goto out;
 
@@ -312,21 +354,19 @@ get_hso_netdev (LibHalContext *ctx, const char *udi)
 		goto out;
 
 	/* Check to ensure we've got the actual "USB Device" */
-	bus = libhal_device_get_property_string (ctx, serial_od_parent, "info.bus", NULL);
-	if (!bus || strcmp (bus, "usb_device")) {
-		libhal_free_string (bus);
+	subsys = hal_get_subsystem (ctx, serial_od_parent);
+	if (!subsys || strcmp (subsys, "usb_device")) {
+		libhal_free_string (subsys);
 		goto out;
 	}
-	libhal_free_string (bus);
+	libhal_free_string (subsys);
 
 	/* Look for the originating device's netdev */
 	netdevs = libhal_find_device_by_capability (ctx, "net", &num, NULL);
 	for (i = 0; netdevs && !netdev && (i < num); i++) {
 		char *net_od = NULL, *net_od_parent = NULL, *tmp;
 
-		net_od = libhal_device_get_property_string (ctx, netdevs[i], "net.originating_device", NULL);
-		if (!net_od)
-			net_od = libhal_device_get_property_string (ctx, netdevs[i], "net.physical_device", NULL);
+		net_od = hal_get_originating_device (ctx, netdevs[i], "net");
 		if (!net_od)
 			goto next;
 
@@ -335,12 +375,12 @@ get_hso_netdev (LibHalContext *ctx, const char *udi)
 			goto next;
 
 		/* Check to ensure we've got the actual "USB Device" */
-		bus = libhal_device_get_property_string (ctx, net_od_parent, "info.bus", NULL);
-		if (!bus || strcmp (bus, "usb_device")) {
-			libhal_free_string (bus);
+		subsys = hal_get_subsystem (ctx, net_od_parent);
+		if (!subsys || strcmp (subsys, "usb_device")) {
+			libhal_free_string (subsys);
 			goto next;
 		}
-		libhal_free_string (bus);
+		libhal_free_string (subsys);
 
 		if (!strcmp (net_od_parent, serial_od_parent)) {
 			/* We found it */
@@ -851,22 +891,16 @@ new_modem_device (const char *udi,
 static char *
 nm_get_modem_device_driver_name (LibHalContext *ctx, const char *udi)
 {
-	char *driver_name = NULL;
-	char *origdev_udi;
+	char *driver_name = NULL, *origdev_udi, *driver;
 
-	origdev_udi = libhal_device_get_property_string (ctx, udi, "serial.originating_device", NULL);
-	/* Older HAL uses "physical_device" */
+	origdev_udi = hal_get_originating_device (ctx, udi, "serial");
 	if (!origdev_udi)
-		origdev_udi = libhal_device_get_property_string (ctx, udi, "serial.physical_device", NULL);
-
-	if (origdev_udi && libhal_device_property_exists (ctx, origdev_udi, "info.linux.driver", NULL)) {
-		char *drv;
+		return NULL;
 
-		drv = libhal_device_get_property_string (ctx, origdev_udi, "info.linux.driver", NULL);
-		if (drv) {
-			driver_name = g_strdup (drv);
-			libhal_free_string (drv);
-		}
+	driver = libhal_device_get_property_string (ctx, origdev_udi, "info.linux.driver", NULL);
+	if (driver) {
+		driver_name = g_strdup (driver);
+		libhal_free_string (driver);
 	}
 	libhal_free_string (origdev_udi);
 	return driver_name;
@@ -1039,7 +1073,7 @@ static void
 emit_udi_added (NMHalManager *self, const char *udi, DeviceCreator *creator)
 {
 	NMHalManagerPrivate *priv = NM_HAL_MANAGER_GET_PRIVATE (self);
-	char *od = NULL, *tmp, *parent, *bus = NULL;
+	char *od = NULL, *tmp, *parent, *subsys = NULL;
 
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (udi != NULL);
@@ -1056,8 +1090,8 @@ emit_udi_added (NMHalManager *self, const char *udi, DeviceCreator *creator)
 	 */
 	parent = libhal_device_get_property_string (priv->hal_ctx, udi, "info.parent", NULL);
 	if (parent)
-		bus = libhal_device_get_property_string (priv->hal_ctx, parent, "info.bus", NULL);
-	if (bus && !strcmp (bus, "usb")) {
+		subsys = hal_get_subsystem (priv->hal_ctx, parent);
+	if (subsys && !strcmp (subsys, "usb")) {
 		char *usb_intf_udi;
 
 		usb_intf_udi = libhal_device_get_property_string (priv->hal_ctx, udi, "info.parent", NULL);
@@ -1066,7 +1100,7 @@ emit_udi_added (NMHalManager *self, const char *udi, DeviceCreator *creator)
 
 			/* Ensure the grandparent really is the "USB Device" */
 			if (od) {
-				tmp = libhal_device_get_property_string (priv->hal_ctx, od, "info.bus", NULL);
+				tmp = hal_get_subsystem (priv->hal_ctx, od);
 				if (!tmp || strcmp (tmp, "usb_device")) {
 					libhal_free_string (od);
 					od = NULL;
@@ -1077,24 +1111,15 @@ emit_udi_added (NMHalManager *self, const char *udi, DeviceCreator *creator)
 			libhal_free_string (usb_intf_udi);
 		}
 	}
-	libhal_free_string (bus);
+	libhal_free_string (subsys);
 	libhal_free_string (parent);
 
-	/* For non-USB devices, and ss a fallback, just use the originating device
-	 * of the tty; though this might result in more than one modem being detected by NM.
+	/* For non-USB devices, and as a fallback, just use the originating device
+	 * of the tty; though this might result in more than one modem being
+	 * detected by NM.
 	 */
-	if (!od) {
-		tmp = g_strdup_printf ("%s.originating_device", creator->category);
-		od = libhal_device_get_property_string (priv->hal_ctx, udi, tmp, NULL);
-		g_free (tmp);
-	}
-
-	if (!od) {
-		/* Older HAL uses 'physical_device' */
-		tmp = g_strdup_printf ("%s.physical_device", creator->category);
-		od = libhal_device_get_property_string (priv->hal_ctx, udi, tmp, NULL);
-		g_free (tmp);
-	}
+	if (!od)
+		od = hal_get_originating_device (priv->hal_ctx, udi, creator->category);
 
 	g_signal_emit (self, signals[UDI_ADDED], 0,
 	               udi,
-- 
1.6.3.3

