Description: Allow to unmanage bridge ports
 Parse bridge configurations in /etc/network/interfaces and add
 interfaces defined via bridge_ports to well_known_interfaces. This
 allows to mark those interfaces as unmanaged if managed=false.
 The "all" keyword and regexes are not supported and simply skipped.
Author: Michael Biebl <biebl@debian.org>
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=530335
Index: network-manager/system-settings/plugins/ifupdown/plugin.c
===================================================================
--- network-manager.orig/system-settings/plugins/ifupdown/plugin.c	2010-12-05 04:27:03.157754436 +0100
+++ network-manager/system-settings/plugins/ifupdown/plugin.c	2010-12-05 04:27:09.541753340 +0100
@@ -362,9 +362,49 @@
 	while (block) {
 		if(!strcmp ("auto", block->type) || !strcmp ("allow-hotplug", block->type))
 			g_hash_table_insert (auto_ifaces, block->name, GUINT_TO_POINTER (1));
-		else if (!strcmp ("iface", block->type) && strcmp ("lo", block->name)) {
+		else if (!strcmp ("iface", block->type)) {
 			NMIfupdownConnection *exported;
 
+			/* Bridge configuration */
+			if(!strncmp ("br", block->name, 2)) {
+				/* Try to find bridge ports */
+				const char *ports = ifparser_getkey (block, "bridge_ports");
+				if (ports) {
+					PLUGIN_PRINT("SCPlugin-Ifupdown", "found bridge ports %s for %s", ports, block->name);
+					char **port_ifaces = g_strsplit_set (ports, " \t", -1);
+
+					int i;
+					int state = 0;
+					for (i = 0; i < g_strv_length (port_ifaces); i++) {
+						char *token = port_ifaces[i];
+						/* Skip crazy stuff like regex or all */
+						if (!strcmp ("all", token)) {
+							continue;
+						}
+						/* Small SM to skip everything inside regex */
+						if (!strcmp ("regex", token)) {
+							state++;
+							continue;
+						}
+						if (!strcmp ("noregex", token)) {
+							state--;
+							continue;
+						}
+						if (state == 0 && strlen (token) > 0) {
+							PLUGIN_PRINT("SCPlugin-Ifupdown", "adding bridge port %s to well_known_interfaces", token);
+							g_hash_table_insert (priv->well_known_interfaces, g_strdup (token), "known");
+						}
+					}
+					g_strfreev (port_ifaces);
+				}
+				goto next;
+			}
+
+			/* Skip loopback configuration */
+			if(!strcmp ("lo", block->name)) {
+				goto next;
+			}
+
 			/* Remove any connection for this block that was previously found */
 			exported = g_hash_table_lookup (priv->iface_connections, block->name);
 			if (exported) {
@@ -387,6 +427,7 @@
 			g_hash_table_insert (priv->well_known_interfaces, block->name, "known");
 			PLUGIN_PRINT("SCPlugin-Ifupdown", "adding mapping %s to well_known_interfaces", block->name);
 		}
+	next:
 		block = block->next;
 	}
 
