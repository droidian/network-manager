Description: Force online state with unmanaged devices
 If we have unmanaged devices in /e/n/i, monitor the ifupdown state file
 and in case we find active interfaces besides lo, forcefully set the
 online state to CONNECTED.
Author: Michael Biebl <biebl@debian.org>
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=512286
--- a/src/nm-manager.c
+++ b/src/nm-manager.c
@@ -78,6 +78,8 @@
 #define NM_AUTOIP_DBUS_SERVICE "org.freedesktop.nm_avahi_autoipd"
 #define NM_AUTOIP_DBUS_IFACE   "org.freedesktop.nm_avahi_autoipd"
 
+#define IFUPDOWN_STATE_FILE "/run/network/ifstate"
+
 static gboolean impl_manager_get_devices (NMManager *manager,
                                           GPtrArray **devices,
                                           GError **err);
@@ -249,6 +251,11 @@
 	guint fw_monitor_id;
 	guint fw_changed_id;
 
+	/* ifupdown state file monitor */
+	GFileMonitor *ifstate_monitor;
+	guint ifstate_monitor_id;
+	gboolean ifstate_force_online;
+
 	guint timestamp_update_id;
 
 	GHashTable *nm_bridges;
@@ -618,6 +625,14 @@
 				}
 			}
 
+			if (state == NM_DEVICE_STATE_UNMANAGED) {
+				const char *iface = nm_device_get_ip_iface (dev);
+				if (priv->ifstate_force_online) {
+					new_state = NM_STATE_CONNECTED;
+					nm_log_dbg (LOGD_CORE, "Unmanaged device found: %s; state CONNECTED forced.", iface);
+				}
+			}
+
 			if (nm_device_is_activating (dev))
 				new_state = NM_STATE_CONNECTING;
 			else if (new_state != NM_STATE_CONNECTING) {
@@ -4090,6 +4105,65 @@
 	}
 }
 
+static void
+check_ifstate_file (gpointer user_data)
+{
+	NMManager *self = NM_MANAGER (user_data);
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	GIOChannel *channel;
+	gchar *line;
+	gboolean online = FALSE;
+
+	channel = g_io_channel_new_file (IFUPDOWN_STATE_FILE, "r", NULL);
+	if (!channel) {
+		nm_log_warn (LOGD_CORE, "Error: failed to open %s", IFUPDOWN_STATE_FILE);
+		return;
+	}
+	
+	while (g_io_channel_read_line (channel, &line, NULL, NULL, NULL)
+	       != G_IO_STATUS_EOF && !online) {
+		g_strstrip (line);
+		if (strlen (line) > 0 && g_strcmp0 (line, "lo=lo") != 0) {
+			online = TRUE;
+		}
+		g_free (line);
+	}
+	
+	g_io_channel_shutdown (channel, FALSE, NULL);
+	g_io_channel_unref (channel);
+
+	if (priv->ifstate_force_online != online) {
+		priv->ifstate_force_online = online;
+		nm_manager_update_state (self);
+	}
+}
+
+static void
+ifstate_file_changed (GFileMonitor *monitor,
+                      GFile *file,
+                      GFile *other_file,
+                      GFileMonitorEvent event_type,
+                      gpointer user_data)
+{
+	NMManager *self = NM_MANAGER (user_data);
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+
+	switch (event_type) {
+//	case G_FILE_MONITOR_EVENT_CREATED:
+//#if GLIB_CHECK_VERSION(2,23,4)
+//	case G_FILE_MONITOR_EVENT_MOVED:
+//#endif
+//	case G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED:
+	case G_FILE_MONITOR_EVENT_CHANGED:
+	case G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT:
+		nm_log_dbg (LOGD_CORE, "ifupdown state file %s was changed", IFUPDOWN_STATE_FILE);
+		check_ifstate_file (user_data);
+		break;
+	default:
+		break;
+	}
+}
+
 #define NM_PERM_DENIED_ERROR "org.freedesktop.NetworkManager.PermissionDenied"
 #define DEV_PERM_DENIED_ERROR "org.freedesktop.NetworkManager.Device.PermissionDenied"
 
@@ -4506,6 +4580,17 @@
 		g_object_unref (priv->fw_monitor);
 	}
 
+	if (priv->ifstate_monitor) {
+		if (priv->ifstate_monitor_id)
+			g_signal_handler_disconnect (priv->ifstate_monitor, priv->ifstate_monitor_id);
+
+		if (priv->ifstate_force_online)
+			g_source_remove (priv->ifstate_force_online);
+
+		g_file_monitor_cancel (priv->ifstate_monitor);
+		g_object_unref (priv->ifstate_monitor);
+	}
+
 	g_slist_free (priv->factories);
 
 	if (priv->timestamp_update_id) {
@@ -4865,6 +4950,23 @@
 		             KERNEL_FIRMWARE_DIR);
 	}
 
+	/* Monitor the ifupdown state file */
+	file = g_file_new_for_path (IFUPDOWN_STATE_FILE);
+	priv->ifstate_monitor = g_file_monitor_file (file, G_FILE_MONITOR_NONE, NULL, NULL);
+	g_object_unref (file);
+
+	if (priv->ifstate_monitor) {
+		priv->ifstate_monitor_id = g_signal_connect (priv->ifstate_monitor, "changed",
+		                                             G_CALLBACK (ifstate_file_changed),
+		                                             manager);
+		nm_log_info (LOGD_CORE, "monitoring ifupdown state file '%s'.",
+		             IFUPDOWN_STATE_FILE);
+	} else {
+		nm_log_warn (LOGD_CORE, "failed to monitor ifupdown state file '%s'.",
+		             IFUPDOWN_STATE_FILE);
+	}
+	check_ifstate_file (manager);
+
 	load_device_factories (manager);
 
 	/* Update timestamps in active connections */
