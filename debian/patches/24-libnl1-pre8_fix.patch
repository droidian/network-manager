=== modified file 'src/NetworkManagerSystem.c'
--- src/NetworkManagerSystem.c	2007-12-20 06:06:27 +0000
+++ src/NetworkManagerSystem.c	2007-12-20 06:57:47 +0000
@@ -224,16 +224,33 @@
 
 static struct nl_handle * new_nl_handle (void)
 {
-	struct nl_handle *	nlh = NULL;
-
-	nlh = nl_handle_alloc_nondefault(NL_CB_VERBOSE);
-	nl_handle_set_pid (nlh, (pthread_self() << 16 | getpid()));
-	if (nl_connect(nlh, NETLINK_ROUTE) < 0)
-	{
-		nm_warning ("%s: couldn't connecto to netlink: %s", __func__, nl_geterror());
+	struct nl_handle * nlh = NULL;
+	struct nl_cb *cb;
+
+	cb = nl_cb_alloc (NL_CB_VERBOSE);
+	nlh = nl_handle_alloc_cb (cb);
+
+	if (!nlh) {
+		nm_warning ("couldn't allocate netlink handle.");
+		return NULL;
+	}
+
+	if (nl_connect (nlh, NETLINK_ROUTE) < 0) {
+        	/* HACK: try one more time. Because the netlink monitor for link state
+                 * inits before we get here, it grabs the port that matches the PID
+                 * of the NM process, which also happens to be the PID that libnl uses
+                 * the first time too.  The real fix is to convert nm-netlink-monitor.c
+                 * over to use libnl.
+                 */
 		nl_handle_destroy (nlh);
 		nlh = NULL;
-	}
+
+		nlh = new_nl_handle ();
+		if (!nlh) {
+			nm_error ("couldn't connect to netlink: %s", nl_geterror ());
+			return NULL;
+		}
+        }
 
 	return nlh;
 }

