--- network-manager-0.6.2.orig/src/nm-device-802-11-wireless.c	2006-05-05 02:13:37.000000000 -0500
+++ network-manager-0.6.2/src/nm-device-802-11-wireless.c	2006-05-05 02:20:23.000000000 -0500
@@ -60,7 +60,7 @@
 
 struct _NMDevice80211WirelessPrivate
 {
-	gboolean	dispose_has_run;
+	gboolean	is_initialized;
 
 	struct ether_addr	hw_addr;
 
@@ -242,7 +242,7 @@
 nm_device_802_11_wireless_init (NMDevice80211Wireless * self)
 {
 	self->priv = NM_DEVICE_802_11_WIRELESS_GET_PRIVATE (self);
-	self->priv->dispose_has_run = FALSE;
+	self->priv->is_initialized = FALSE;
 
 	memset (&(self->priv->hw_addr), 0, sizeof (struct ether_addr));
 	self->priv->supplicant.pid = -1;
@@ -256,6 +256,7 @@
 	guint32				caps;
 	NMSock *				sk;
 
+	self->priv->is_initialized = TRUE;
 	self->priv->scan_mutex = g_mutex_new ();
 	nm_register_mutex_desc (self->priv->scan_mutex, "Scan Mutex");
 
@@ -2988,24 +2989,22 @@
 	NMDevice80211WirelessClass *	klass = NM_DEVICE_802_11_WIRELESS_GET_CLASS (object);
 	NMDeviceClass *			parent_class;
 
-	if (self->priv->dispose_has_run)
-		/* If dispose did already run, return. */
-		return;
-
-	/* Make sure dispose does not run twice. */
-	self->priv->dispose_has_run = TRUE;
-
-	/* 
-	 * In dispose, you are supposed to free all types referenced from this
-	 * object which might themselves hold a reference to self. Generally,
-	 * the most simple solution is to unref all members on which you own a 
-	 * reference.
-	 */
-
-	nm_device_802_11_wireless_ap_list_clear (self);
-	if (self->priv->ap_list)
-		nm_ap_list_unref (self->priv->ap_list);
-	g_mutex_free (self->priv->scan_mutex);
+	/* Only do this part of the cleanup if the object is initialized */
+	if (self->priv->is_initialized) {
+		self->priv->is_initialized = FALSE;
+
+		/* 
+		* In dispose, you are supposed to free all types referenced from this
+		* object which might themselves hold a reference to self. Generally,
+		* the most simple solution is to unref all members on which you own a 
+		* reference.
+		*/
+
+		nm_device_802_11_wireless_ap_list_clear (self);
+		if (self->priv->ap_list)
+			nm_ap_list_unref (self->priv->ap_list);
+		g_mutex_free (self->priv->scan_mutex);
+	}
 
 	/* Chain up to the parent class */
 	parent_class = NM_DEVICE_CLASS (g_type_class_peek_parent (klass));
